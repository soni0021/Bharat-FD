{"ast":null,"code":"import FAQ from '../models/faq.model.js';\nimport { getCache, setCache } from '../utils/cache.js';\nimport { translateFAQ } from '../services/translate.proxy.js';\nexport const getFAQs = async (req, res) => {\n  try {\n    // Optionally filter by language, or return all FAQs\n    const language = req.query.language || 'en';\n    const faqs = await FAQ.find({\n      language\n    });\n    res.status(200).json(faqs);\n  } catch (error) {\n    res.status(500).json({\n      message: error.message\n    });\n  }\n};\nexport const createFAQ = async (req, res) => {\n  try {\n    // Destructure the required fields from the request body\n    const {\n      question,\n      answer,\n      language = 'en'\n    } = req.body;\n\n    // Create a new FAQ instance with the received data\n    const newFAQ = new FAQ({\n      question,\n      answer,\n      language\n    });\n\n    // Save the FAQ to the database\n    await newFAQ.save();\n\n    // Optionally, run translation logic if needed\n    if (req.body.autoTranslate) {\n      await translateFAQ(newFAQ);\n    }\n\n    // Respond back with the saved object, including its _id\n    res.status(201).json(newFAQ);\n  } catch (error) {\n    res.status(400).json({\n      message: error.message\n    });\n  }\n};\n\n// Updated updateFAQ to accept and update additional fields (including translations)\nexport const updateFAQ = async (req, res) => {\n  try {\n    const {\n      id\n    } = req.params;\n    // Instead of destructuring only question, answer, language, update with the entire payload\n    const updateData = req.body;\n    const updatedFAQ = await FAQ.findByIdAndUpdate(id, updateData, {\n      new: true\n    });\n    if (!updatedFAQ) {\n      return res.status(404).json({\n        message: 'FAQ not found'\n      });\n    }\n    res.status(200).json(updatedFAQ);\n  } catch (error) {\n    res.status(400).json({\n      message: error.message\n    });\n  }\n};\nexport const deleteFAQ = async (req, res) => {\n  try {\n    const {\n      id\n    } = req.params;\n    const deletedFAQ = await FAQ.findByIdAndDelete(id);\n    if (!deletedFAQ) {\n      return res.status(404).json({\n        message: 'FAQ not found'\n      });\n    }\n    res.status(200).json({\n      message: 'FAQ deleted successfully'\n    });\n  } catch (error) {\n    res.status(400).json({\n      message: error.message\n    });\n  }\n};","map":{"version":3,"names":["FAQ","getCache","setCache","translateFAQ","getFAQs","req","res","language","query","faqs","find","status","json","error","message","createFAQ","question","answer","body","newFAQ","save","autoTranslate","updateFAQ","id","params","updateData","updatedFAQ","findByIdAndUpdate","new","deleteFAQ","deletedFAQ","findByIdAndDelete"],"sources":["/Users/manishsoni/BFD FAQ/frontend/src/components/FAQEditor/FAQEditor.jsx"],"sourcesContent":["import FAQ from '../models/faq.model.js';\nimport { getCache, setCache } from '../utils/cache.js';\nimport { translateFAQ } from '../services/translate.proxy.js';\n\nexport const getFAQs = async (req, res) => {\n  try {\n    // Optionally filter by language, or return all FAQs\n    const language = req.query.language || 'en';\n    const faqs = await FAQ.find({ language });\n    res.status(200).json(faqs);\n  } catch (error) {\n    res.status(500).json({ message: error.message });\n  }\n};\n\nexport const createFAQ = async (req, res) => {\n  try {\n    // Destructure the required fields from the request body\n    const { question, answer, language = 'en' } = req.body;\n\n    // Create a new FAQ instance with the received data\n    const newFAQ = new FAQ({ question, answer, language });\n    \n    // Save the FAQ to the database\n    await newFAQ.save();\n\n    // Optionally, run translation logic if needed\n    if (req.body.autoTranslate) {\n      await translateFAQ(newFAQ);\n    }\n    \n    // Respond back with the saved object, including its _id\n    res.status(201).json(newFAQ);\n  } catch (error) {\n    res.status(400).json({ message: error.message });\n  }\n};\n\n// Updated updateFAQ to accept and update additional fields (including translations)\nexport const updateFAQ = async (req, res) => {\n  try {\n    const { id } = req.params;\n    // Instead of destructuring only question, answer, language, update with the entire payload\n    const updateData = req.body;\n    const updatedFAQ = await FAQ.findByIdAndUpdate(id, updateData, { new: true });\n    if (!updatedFAQ) {\n      return res.status(404).json({ message: 'FAQ not found' });\n    }\n    res.status(200).json(updatedFAQ);\n  } catch (error) {\n    res.status(400).json({ message: error.message });\n  }\n};\n\nexport const deleteFAQ = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const deletedFAQ = await FAQ.findByIdAndDelete(id);\n    if (!deletedFAQ) {\n      return res.status(404).json({ message: 'FAQ not found' });\n    }\n    res.status(200).json({ message: 'FAQ deleted successfully' });\n  } catch (error) {\n    res.status(400).json({ message: error.message });\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}