{"ast":null,"code":"var diff = require('fast-diff');\nvar is = require('./is');\nvar op = require('./op');\nvar NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\n\nvar Delta = function (ops) {\n  // Assume we are given a well formed ops\n  if (is.array(ops)) {\n    this.ops = ops;\n  } else if (is.object(ops) && is.array(ops.ops)) {\n    this.ops = ops.ops;\n  } else {\n    this.ops = [];\n  }\n};\nDelta.prototype.insert = function (text, attributes) {\n  var newOp = {};\n  if (is.string(text)) {\n    if (text.length === 0) return this;\n    newOp.insert = text;\n  } else if (is.number(text)) {\n    newOp.insert = text;\n  }\n  if (is.object(attributes) && Object.keys(attributes).length > 0) newOp.attributes = attributes;\n  return this.push(newOp);\n};\nDelta.prototype['delete'] = function (length) {\n  if (length <= 0) return this;\n  return this.push({\n    'delete': length\n  });\n};\nDelta.prototype.retain = function (length, attributes) {\n  if (length <= 0) return this;\n  var newOp = {\n    retain: length\n  };\n  if (is.object(attributes) && Object.keys(attributes).length > 0) newOp.attributes = attributes;\n  return this.push(newOp);\n};\nDelta.prototype.push = function (newOp) {\n  var index = this.ops.length;\n  var lastOp = this.ops[index - 1];\n  newOp = op.clone(newOp);\n  if (is.object(lastOp)) {\n    if (is.number(newOp['delete']) && is.number(lastOp['delete'])) {\n      this.ops[index - 1] = {\n        'delete': lastOp['delete'] + newOp['delete']\n      };\n      return this;\n    }\n    // Since it does not matter if we insert before or after deleting at the same index,\n    // always prefer to insert first\n    if (is.number(lastOp['delete']) && (is.string(newOp.insert) || is.number(newOp.insert))) {\n      index -= 1;\n      lastOp = this.ops[index - 1];\n      if (!is.object(lastOp)) {\n        this.ops.unshift(newOp);\n        return this;\n      }\n    }\n    if (is.equal(newOp.attributes, lastOp.attributes)) {\n      if (is.string(newOp.insert) && is.string(lastOp.insert)) {\n        this.ops[index - 1] = {\n          insert: lastOp.insert + newOp.insert\n        };\n        if (is.object(newOp.attributes)) this.ops[index - 1].attributes = newOp.attributes;\n        return this;\n      } else if (is.number(newOp.retain) && is.number(lastOp.retain)) {\n        this.ops[index - 1] = {\n          retain: lastOp.retain + newOp.retain\n        };\n        if (is.object(newOp.attributes)) this.ops[index - 1].attributes = newOp.attributes;\n        return this;\n      }\n    }\n  }\n  this.ops.splice(index, 0, newOp);\n  return this;\n};\nDelta.prototype.chop = function () {\n  var lastOp = this.ops[this.ops.length - 1];\n  if (lastOp && lastOp.retain && !lastOp.attributes) {\n    this.ops.pop();\n  }\n  return this;\n};\nDelta.prototype.length = function () {\n  return this.ops.reduce(function (length, elem) {\n    return length + op.length(elem);\n  }, 0);\n};\nDelta.prototype.slice = function (start, end) {\n  start = start || 0;\n  if (!is.number(end)) end = Infinity;\n  var delta = new Delta();\n  var iter = op.iterator(this.ops);\n  var index = 0;\n  while (index < end && iter.hasNext()) {\n    var nextOp;\n    if (index < start) {\n      nextOp = iter.next(start - index);\n    } else {\n      nextOp = iter.next(end - index);\n      delta.push(nextOp);\n    }\n    index += op.length(nextOp);\n  }\n  return delta;\n};\nDelta.prototype.compose = function (other) {\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  this.ops = [];\n  while (thisIter.hasNext() || otherIter.hasNext()) {\n    if (otherIter.peekType() === 'insert') {\n      this.push(otherIter.next());\n    } else if (thisIter.peekType() === 'delete') {\n      this.push(thisIter.next());\n    } else {\n      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n      var thisOp = thisIter.next(length);\n      var otherOp = otherIter.next(length);\n      if (is.number(otherOp.retain)) {\n        var newOp = {};\n        if (is.number(thisOp.retain)) {\n          newOp.retain = length;\n        } else {\n          newOp.insert = thisOp.insert;\n        }\n        // Preserve null when composing with a retain, otherwise remove it for inserts\n        var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, is.number(thisOp.retain));\n        if (attributes) newOp.attributes = attributes;\n        this.push(newOp);\n        // Other op should be delete, we could be an insert or retain\n        // Insert + delete cancels out\n      } else if (is.number(otherOp['delete']) && is.number(thisOp.retain)) {\n        this.push(otherOp);\n      }\n    }\n  }\n  return this.chop();\n};\nDelta.prototype.diff = function (other) {\n  var strings = [this.ops, other.ops].map(function (ops) {\n    return ops.map(function (op) {\n      if (is.string(op.insert)) return op.insert;\n      if (is.number(op.insert)) return NULL_CHARACTER;\n      var prep = ops === other.ops ? 'on' : 'with';\n      throw new Error('diff() called ' + prep + ' non-document');\n    }).join('');\n  });\n  var diffResult = diff(strings[0], strings[1]);\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  var delta = new Delta();\n  diffResult.forEach(function (component) {\n    var length = component[1].length;\n    while (length > 0) {\n      var opLength = 0;\n      switch (component[0]) {\n        case diff.INSERT:\n          opLength = Math.min(otherIter.peekLength(), length);\n          delta.push(otherIter.next(opLength));\n          break;\n        case diff.DELETE:\n          opLength = Math.min(length, thisIter.peekLength());\n          thisIter.next(opLength);\n          delta['delete'](opLength);\n          break;\n        case diff.EQUAL:\n          opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n          var thisOp = thisIter.next(opLength);\n          var otherOp = otherIter.next(opLength);\n          if (thisOp.insert === otherOp.insert) {\n            delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));\n          } else {\n            delta.push(otherOp)['delete'](opLength);\n          }\n          break;\n      }\n      length -= opLength;\n    }\n  });\n  return delta.chop();\n};\nDelta.prototype.transform = function (other, priority) {\n  priority = !!priority;\n  if (is.number(other)) {\n    return this.transformPosition(other, priority);\n  }\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  var delta = new Delta();\n  while (thisIter.hasNext() || otherIter.hasNext()) {\n    if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {\n      delta.retain(op.length(thisIter.next()));\n    } else if (otherIter.peekType() === 'insert') {\n      delta.push(otherIter.next());\n    } else {\n      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n      var thisOp = thisIter.next(length);\n      var otherOp = otherIter.next(length);\n      if (thisOp['delete']) {\n        // Our delete either makes their delete redundant or removes their retain\n        continue;\n      } else if (otherOp['delete']) {\n        delta.push(otherOp);\n      } else {\n        // We retain either their retain or insert\n        delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));\n      }\n    }\n  }\n  return delta.chop();\n};\nDelta.prototype.transformPosition = function (index, priority) {\n  priority = !!priority;\n  var thisIter = op.iterator(this.ops);\n  var offset = 0;\n  while (thisIter.hasNext() && offset <= index) {\n    var length = thisIter.peekLength();\n    var nextType = thisIter.peekType();\n    thisIter.next();\n    if (nextType === 'delete') {\n      index -= Math.min(length, index - offset);\n      continue;\n    } else if (nextType === 'insert' && (offset < index || !priority)) {\n      index += length;\n    }\n    offset += length;\n  }\n  return index;\n};\nmodule.exports = Delta;","map":null,"metadata":{},"sourceType":"script"}