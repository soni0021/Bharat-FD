{"ast":null,"code":"var SelectWrapper,\n  Wrapper,\n  dom,\n  lastKeyEvent,\n  _,\n  __bind = function (fn, me) {\n    return function () {\n      return fn.apply(me, arguments);\n    };\n  },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function (child, parent) {\n    for (var key in parent) {\n      if (__hasProp.call(parent, key)) child[key] = parent[key];\n    }\n    function ctor() {\n      this.constructor = child;\n    }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  };\n_ = require('lodash');\nlastKeyEvent = null;\nWrapper = function () {\n  function Wrapper(node) {\n    this.node = node;\n    this.trigger = __bind(this.trigger, this);\n  }\n  Wrapper.prototype.addClass = function (cssClass) {\n    if (this.hasClass(cssClass)) {\n      return;\n    }\n    if (this.node.classList != null) {\n      this.node.classList.add(cssClass);\n    } else if (this.node.className != null) {\n      this.node.className = (this.node.className + ' ' + cssClass).trim();\n    }\n    return this;\n  };\n  Wrapper.prototype.attributes = function (attributes) {\n    var attr, i, value, _i, _len, _ref;\n    if (attributes) {\n      _.each(attributes, function (_this) {\n        return function (value, name) {\n          return _this.node.setAttribute(name, value);\n        };\n      }(this));\n      return this;\n    } else {\n      if (this.node.attributes == null) {\n        return {};\n      }\n      attributes = {};\n      _ref = this.node.attributes;\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        value = _ref[i];\n        attr = this.node.attributes[i];\n        attributes[attr.name] = attr.value;\n      }\n      return attributes;\n    }\n  };\n  Wrapper.prototype.child = function (offset) {\n    var child, length;\n    child = this.node.firstChild;\n    length = dom(child).length();\n    while (child != null) {\n      if (offset < length) {\n        break;\n      }\n      offset -= length;\n      child = child.nextSibling;\n      length = dom(child).length();\n    }\n    if (child == null) {\n      child = this.node.lastChild;\n      offset = dom(child).length();\n    }\n    return [child, offset];\n  };\n  Wrapper.prototype.childNodes = function () {\n    return _.map(this.node.childNodes);\n  };\n  Wrapper.prototype.classes = function () {\n    return this.node.className.split(/\\s+/);\n  };\n  Wrapper.prototype.descendants = function () {\n    return _.map(this.node.getElementsByTagName('*'));\n  };\n  Wrapper.prototype.get = function () {\n    return this.node;\n  };\n  Wrapper.prototype.hasClass = function (cssClass) {\n    if (this.node.classList != null) {\n      return this.node.classList.contains(cssClass);\n    } else if (this.node.className != null) {\n      return _.indexOf(this.classes(), cssClass) > -1;\n    }\n    return false;\n  };\n  Wrapper.prototype.isAncestor = function (ancestor, inclusive) {\n    var node;\n    if (inclusive == null) {\n      inclusive = false;\n    }\n    if (ancestor === this.node) {\n      return inclusive;\n    }\n    node = this.node;\n    while (node) {\n      if (node === ancestor) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  };\n  Wrapper.prototype.isElement = function () {\n    var _ref;\n    return ((_ref = this.node) != null ? _ref.nodeType : void 0) === dom.ELEMENT_NODE;\n  };\n  Wrapper.prototype.isTextNode = function () {\n    var _ref;\n    return ((_ref = this.node) != null ? _ref.nodeType : void 0) === dom.TEXT_NODE;\n  };\n  Wrapper.prototype.length = function () {\n    var length;\n    if (this.node == null) {\n      return 0;\n    }\n    length = this.text().length;\n    if (this.isElement()) {\n      length += this.node.querySelectorAll(_.keys(dom.EMBED_TAGS).join(',')).length;\n    }\n    return length;\n  };\n  Wrapper.prototype.merge = function (node) {\n    var $node;\n    $node = dom(node);\n    if (this.isElement()) {\n      $node.moveChildren(this.node);\n      this.normalize();\n    } else {\n      this.text(this.text() + $node.text());\n    }\n    $node.remove();\n    return this;\n  };\n  Wrapper.prototype.moveChildren = function (newParent) {\n    _.each(this.childNodes(), function (child) {\n      return newParent.appendChild(child);\n    });\n    return this;\n  };\n  Wrapper.prototype.nextLineNode = function (root) {\n    var nextNode;\n    nextNode = this.node.nextSibling;\n    if (nextNode == null && this.node.parentNode !== root) {\n      nextNode = this.node.parentNode.nextSibling;\n    }\n    if (nextNode != null && dom.LIST_TAGS[nextNode.tagName] != null) {\n      nextNode = nextNode.firstChild;\n    }\n    return nextNode;\n  };\n  Wrapper.prototype.normalize = function () {\n    var $node, curNode, followingNode, nextNode;\n    curNode = this.node.firstChild;\n    while (curNode != null) {\n      nextNode = curNode.nextSibling;\n      $node = dom(curNode);\n      if (nextNode != null && dom(nextNode).isTextNode()) {\n        if ($node.text().length === 0) {\n          $node.remove();\n        } else if ($node.isTextNode()) {\n          followingNode = nextNode.nextSibling;\n          $node.merge(nextNode);\n          nextNode = followingNode;\n        }\n      }\n      curNode = nextNode;\n    }\n    return this;\n  };\n  Wrapper.prototype.on = function (eventName, listener) {\n    this.node.addEventListener(eventName, function (_this) {\n      return function (event) {\n        var arg, propagate;\n        arg = lastKeyEvent && (eventName === 'keydown' || eventName === 'keyup') ? lastKeyEvent : event;\n        propagate = listener.call(_this.node, arg);\n        if (!propagate) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n        return propagate;\n      };\n    }(this));\n    return this;\n  };\n  Wrapper.prototype.remove = function () {\n    var _ref;\n    if ((_ref = this.node.parentNode) != null) {\n      _ref.removeChild(this.node);\n    }\n    this.node = null;\n    return null;\n  };\n  Wrapper.prototype.removeClass = function (cssClass) {\n    var classArray;\n    if (!this.hasClass(cssClass)) {\n      return;\n    }\n    if (this.node.classList != null) {\n      return this.node.classList.remove(cssClass);\n    } else if (this.node.className != null) {\n      classArray = this.classes();\n      classArray.splice(_.indexOf(classArray, cssClass), 1);\n      this.node.className = classArray.join(' ');\n    }\n    return this;\n  };\n  Wrapper.prototype.replace = function (newNode) {\n    this.node.parentNode.replaceChild(newNode, this.node);\n    this.node = newNode;\n    return newNode;\n  };\n  Wrapper.prototype.splitAncestors = function (root, force) {\n    var nextNode, parentClone, parentNode, refNode;\n    if (force == null) {\n      force = false;\n    }\n    if (this.node === root || this.node.parentNode === root) {\n      return this;\n    }\n    if (this.node.previousSibling != null || force) {\n      parentNode = this.node.parentNode;\n      parentClone = parentNode.cloneNode(false);\n      parentNode.parentNode.insertBefore(parentClone, parentNode.nextSibling);\n      refNode = this.node;\n      while (refNode != null) {\n        nextNode = refNode.nextSibling;\n        parentClone.appendChild(refNode);\n        refNode = nextNode;\n      }\n      return dom(parentClone).splitAncestors(root);\n    } else {\n      return dom(this.node.parentNode).splitAncestors(root);\n    }\n  };\n  Wrapper.prototype.split = function (offset, force) {\n    var after, child, childLeft, childRight, left, nextRight, nodeLength, right, _ref, _ref1;\n    if (force == null) {\n      force = false;\n    }\n    nodeLength = this.length();\n    offset = Math.max(0, offset);\n    offset = Math.min(offset, nodeLength);\n    if (!(force || offset !== 0)) {\n      return [this.node.previousSibling, this.node, false];\n    }\n    if (!(force || offset !== nodeLength)) {\n      return [this.node, this.node.nextSibling, false];\n    }\n    if (this.node.nodeType === dom.TEXT_NODE) {\n      after = this.node.splitText(offset);\n      return [this.node, after, true];\n    } else {\n      left = this.node;\n      right = this.node.cloneNode(false);\n      this.node.parentNode.insertBefore(right, left.nextSibling);\n      _ref = this.child(offset), child = _ref[0], offset = _ref[1];\n      _ref1 = dom(child).split(offset), childLeft = _ref1[0], childRight = _ref1[1];\n      while (childRight !== null) {\n        nextRight = childRight.nextSibling;\n        right.appendChild(childRight);\n        childRight = nextRight;\n      }\n      return [left, right, true];\n    }\n  };\n  Wrapper.prototype.styles = function (styles, overwrite) {\n    var obj, styleString;\n    if (overwrite == null) {\n      overwrite = false;\n    }\n    if (styles) {\n      if (!overwrite) {\n        styles = _.defaults(styles, this.styles());\n      }\n      styleString = _.map(styles, function (style, name) {\n        return \"\" + name + \": \" + style;\n      }).join('; ') + ';';\n      this.node.setAttribute('style', styleString);\n      return this;\n    } else {\n      styleString = this.node.getAttribute('style') || '';\n      obj = _.reduce(styleString.split(';'), function (styles, str) {\n        var name, value, _ref;\n        _ref = str.split(':'), name = _ref[0], value = _ref[1];\n        if (name && value) {\n          name = name.trim();\n          value = value.trim();\n          styles[name.toLowerCase()] = value;\n        }\n        return styles;\n      }, {});\n      return obj;\n    }\n  };\n  Wrapper.prototype.switchTag = function (newTag) {\n    var attributes, newNode;\n    newTag = newTag.toUpperCase();\n    if (this.node.tagName === newTag) {\n      return this;\n    }\n    newNode = this.node.ownerDocument.createElement(newTag);\n    attributes = this.attributes();\n    if (dom.VOID_TAGS[newTag] == null) {\n      this.moveChildren(newNode);\n    }\n    this.replace(newNode);\n    return this.attributes(attributes).get();\n  };\n  Wrapper.prototype.text = function (text) {\n    if (text != null) {\n      switch (this.node.nodeType) {\n        case dom.ELEMENT_NODE:\n          this.node.textContent = text;\n          break;\n        case dom.TEXT_NODE:\n          this.node.data = text;\n      }\n      return this;\n    } else {\n      switch (this.node.nodeType) {\n        case dom.ELEMENT_NODE:\n          if (this.node.tagName === dom.DEFAULT_BREAK_TAG) {\n            return \"\";\n          }\n          if (dom.EMBED_TAGS[this.node.tagName] != null) {\n            return dom.EMBED_TEXT;\n          }\n          if (this.node.textContent != null) {\n            return this.node.textContent;\n          }\n          return \"\";\n        case dom.TEXT_NODE:\n          return this.node.data || \"\";\n        default:\n          return \"\";\n      }\n    }\n  };\n  Wrapper.prototype.textNodes = function () {\n    var textNode, textNodes, walker;\n    walker = this.node.ownerDocument.createTreeWalker(this.node, NodeFilter.SHOW_TEXT, null, false);\n    textNodes = [];\n    while (textNode = walker.nextNode()) {\n      textNodes.push(textNode);\n    }\n    return textNodes;\n  };\n  Wrapper.prototype.toggleClass = function (className, state) {\n    if (state == null) {\n      state = !this.hasClass(className);\n    }\n    if (state) {\n      this.addClass(className);\n    } else {\n      this.removeClass(className);\n    }\n    return this;\n  };\n  Wrapper.prototype.trigger = function (eventName, options) {\n    var event, initFn, modifiers;\n    if (options == null) {\n      options = {};\n    }\n    if (_.indexOf(['keypress', 'keydown', 'keyup'], eventName) < 0) {\n      event = this.node.ownerDocument.createEvent('Event');\n      event.initEvent(eventName, options.bubbles, options.cancelable);\n    } else {\n      event = this.node.ownerDocument.createEvent('KeyboardEvent');\n      lastKeyEvent = _.clone(options);\n      if (_.isNumber(options.key)) {\n        lastKeyEvent.which = options.key;\n      } else if (_.isString(options.key)) {\n        lastKeyEvent.which = options.key.toUpperCase().charCodeAt(0);\n      } else {\n        lastKeyEvent.which = 0;\n      }\n      if (dom.isIE(10)) {\n        modifiers = [];\n        if (options.altKey) {\n          modifiers.push('Alt');\n        }\n        if (options.ctrlKey) {\n          modifiers.push('Control');\n        }\n        if (options.metaKey) {\n          modifiers.push('Meta');\n        }\n        if (options.shiftKey) {\n          modifiers.push('Shift');\n        }\n        event.initKeyboardEvent(eventName, options.bubbles, options.cancelable, this.window(), 0, 0, modifiers.join(' '), null, null);\n      } else {\n        initFn = _.isFunction(event.initKeyboardEvent) ? 'initKeyboardEvent' : 'initKeyEvent';\n        event[initFn](eventName, options.bubbles, options.cancelable, this.window(), options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, 0, 0);\n      }\n    }\n    this.node.dispatchEvent(event);\n    lastKeyEvent = null;\n    return this;\n  };\n  Wrapper.prototype.unwrap = function () {\n    var next, ret;\n    ret = this.node.firstChild;\n    next = this.node.nextSibling;\n    _.each(this.childNodes(), function (_this) {\n      return function (child) {\n        return _this.node.parentNode.insertBefore(child, next);\n      };\n    }(this));\n    this.remove();\n    return ret;\n  };\n  Wrapper.prototype.window = function () {\n    return this.node.ownerDocument.defaultView || this.node.ownerDocument.parentWindow;\n  };\n  Wrapper.prototype.wrap = function (wrapper) {\n    var parent;\n    if (this.node.parentNode != null) {\n      this.node.parentNode.insertBefore(wrapper, this.node);\n    }\n    parent = wrapper;\n    while (parent.firstChild != null) {\n      parent = wrapper.firstChild;\n    }\n    parent.appendChild(this.node);\n    return this;\n  };\n  return Wrapper;\n}();\nSelectWrapper = function (_super) {\n  __extends(SelectWrapper, _super);\n  function SelectWrapper() {\n    return SelectWrapper.__super__.constructor.apply(this, arguments);\n  }\n  SelectWrapper.prototype[\"default\"] = function () {\n    return this.node.querySelector('option[selected]');\n  };\n  SelectWrapper.prototype.option = function (option, trigger) {\n    var child, i, value, _i, _len, _ref;\n    if (trigger == null) {\n      trigger = true;\n    }\n    value = _.isElement(option) ? option.value : option;\n    if (value) {\n      value = value.replace(/[^\\w]+/g, '');\n      _ref = this.node.children;\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        child = _ref[i];\n        if (child.value.replace(/[^\\w]+/g, '') === value) {\n          this.node.selectedIndex = i;\n          break;\n        }\n      }\n    } else {\n      this.node.selectedIndex = -1;\n    }\n    if (trigger) {\n      this.trigger('change');\n    }\n    return this;\n  };\n  SelectWrapper.prototype.reset = function (trigger) {\n    var option;\n    if (trigger == null) {\n      trigger = true;\n    }\n    option = this[\"default\"]();\n    if (option != null) {\n      option.selected = true;\n    } else {\n      this.node.selectedIndex = 0;\n    }\n    if (trigger) {\n      this.trigger('change');\n    }\n    return this;\n  };\n  SelectWrapper.prototype.value = function () {\n    if (this.node.selectedIndex > -1) {\n      return this.node.options[this.node.selectedIndex].value;\n    } else {\n      return '';\n    }\n  };\n  return SelectWrapper;\n}(Wrapper);\ndom = function (node) {\n  if ((node != null ? node.tagName : void 0) === 'SELECT') {\n    return new SelectWrapper(node);\n  } else {\n    return new Wrapper(node);\n  }\n};\ndom = _.extend(dom, {\n  ELEMENT_NODE: 1,\n  NOBREAK_SPACE: \"&nbsp;\",\n  TEXT_NODE: 3,\n  ZERO_WIDTH_NOBREAK_SPACE: \"\\uFEFF\",\n  DEFAULT_BLOCK_TAG: 'DIV',\n  DEFAULT_BREAK_TAG: 'BR',\n  DEFAULT_INLINE_TAG: 'SPAN',\n  EMBED_TEXT: '!',\n  FONT_SIZES: {\n    '10px': 1,\n    '13px': 2,\n    '16px': 3,\n    '18px': 4,\n    '24px': 5,\n    '32px': 6,\n    '48px': 7\n  },\n  KEYS: {\n    BACKSPACE: 8,\n    TAB: 9,\n    ENTER: 13,\n    ESCAPE: 27,\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    DELETE: 46\n  },\n  BLOCK_TAGS: {\n    'ADDRESS': 'ADDRESS',\n    'ARTICLE': 'ARTICLE',\n    'ASIDE': 'ASIDE',\n    'AUDIO': 'AUDIO',\n    'BLOCKQUOTE': 'BLOCKQUOTE',\n    'CANVAS': 'CANVAS',\n    'DD': 'DD',\n    'DIV': 'DIV',\n    'DL': 'DL',\n    'FIGCAPTION': 'FIGCAPTION',\n    'FIGURE': 'FIGURE',\n    'FOOTER': 'FOOTER',\n    'FORM': 'FORM',\n    'H1': 'H1',\n    'H2': 'H2',\n    'H3': 'H3',\n    'H4': 'H4',\n    'H5': 'H5',\n    'H6': 'H6',\n    'HEADER': 'HEADER',\n    'HGROUP': 'HGROUP',\n    'LI': 'LI',\n    'OL': 'OL',\n    'OUTPUT': 'OUTPUT',\n    'P': 'P',\n    'PRE': 'PRE',\n    'SECTION': 'SECTION',\n    'TABLE': 'TABLE',\n    'TBODY': 'TBODY',\n    'TD': 'TD',\n    'TFOOT': 'TFOOT',\n    'TH': 'TH',\n    'THEAD': 'THEAD',\n    'TR': 'TR',\n    'UL': 'UL',\n    'VIDEO': 'VIDEO'\n  },\n  EMBED_TAGS: {\n    'IMG': 'IMG'\n  },\n  LINE_TAGS: {\n    'DIV': 'DIV',\n    'LI': 'LI'\n  },\n  LIST_TAGS: {\n    'OL': 'OL',\n    'UL': 'UL'\n  },\n  VOID_TAGS: {\n    'AREA': 'AREA',\n    'BASE': 'BASE',\n    'BR': 'BR',\n    'COL': 'COL',\n    'COMMAND': 'COMMAND',\n    'EMBED': 'EMBED',\n    'HR': 'HR',\n    'IMG': 'IMG',\n    'INPUT': 'INPUT',\n    'KEYGEN': 'KEYGEN',\n    'LINK': 'LINK',\n    'META': 'META',\n    'PARAM': 'PARAM',\n    'SOURCE': 'SOURCE',\n    'TRACK': 'TRACK',\n    'WBR': 'WBR'\n  },\n  convertFontSize: function (size) {\n    var i, s, sources, targets;\n    if (_.isString(size) && size.indexOf('px') > -1) {\n      sources = _.keys(dom.FONT_SIZES);\n      targets = _.values(dom.FONT_SIZES);\n    } else {\n      targets = _.keys(dom.FONT_SIZES);\n      sources = _.values(dom.FONT_SIZES);\n    }\n    for (i in sources) {\n      s = sources[i];\n      if (parseInt(size) <= parseInt(s)) {\n        return targets[i];\n      }\n    }\n    return _.last(targets);\n  },\n  isIE: function (maxVersion) {\n    var version;\n    version = document.documentMode;\n    return version && maxVersion >= version;\n  },\n  isIOS: function () {\n    return /iPhone|iPad/i.test(navigator.userAgent);\n  },\n  isMac: function () {\n    return /Mac/i.test(navigator.platform);\n  }\n});\nmodule.exports = dom;","map":null,"metadata":{},"sourceType":"script"}