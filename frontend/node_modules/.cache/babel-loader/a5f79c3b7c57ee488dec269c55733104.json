{"ast":null,"code":"var Delta, Quill, UndoManager, _;\nQuill = require('../quill');\n_ = Quill.require('lodash');\nDelta = Quill.require('delta');\nUndoManager = function () {\n  UndoManager.DEFAULTS = {\n    delay: 1000,\n    maxStack: 100\n  };\n  UndoManager.hotkeys = {\n    UNDO: {\n      key: 'Z',\n      metaKey: true\n    },\n    REDO: {\n      key: 'Z',\n      metaKey: true,\n      shiftKey: true\n    }\n  };\n  function UndoManager(quill, options) {\n    this.quill = quill;\n    this.options = options != null ? options : {};\n    this.lastRecorded = 0;\n    this.emittedDelta = null;\n    this.clear();\n    this.initListeners();\n  }\n  UndoManager.prototype.initListeners = function () {\n    this.quill.onModuleLoad('keyboard', function (_this) {\n      return function (keyboard) {\n        keyboard.addHotkey(UndoManager.hotkeys.UNDO, function () {\n          _this.undo();\n          return false;\n        });\n        return keyboard.addHotkey(UndoManager.hotkeys.REDO, function () {\n          _this.redo();\n          return false;\n        });\n      };\n    }(this));\n    return this.quill.on(this.quill.constructor.events.TEXT_CHANGE, function (_this) {\n      return function (delta, origin) {\n        if (_.isEqual(delta, _this.emittedDelta)) {\n          return;\n        }\n        _this.record(delta, _this.oldDelta);\n        return _this.oldDelta = _this.quill.getContents();\n      };\n    }(this));\n  };\n  UndoManager.prototype.clear = function () {\n    this.stack = {\n      undo: [],\n      redo: []\n    };\n    return this.oldDelta = this.quill.getContents();\n  };\n  UndoManager.prototype.record = function (changeDelta, oldDelta) {\n    var change, ignored, timestamp, undoDelta;\n    if (!(changeDelta.ops.length > 0)) {\n      return;\n    }\n    this.stack.redo = [];\n    try {\n      undoDelta = this.quill.getContents().diff(this.oldDelta);\n      timestamp = new Date().getTime();\n      if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {\n        change = this.stack.undo.pop();\n        undoDelta = undoDelta.compose(change.undo);\n        changeDelta = change.redo.compose(changeDelta);\n      } else {\n        this.lastRecorded = timestamp;\n      }\n      this.stack.undo.push({\n        redo: changeDelta,\n        undo: undoDelta\n      });\n      if (this.stack.undo.length > this.options.maxStack) {\n        return this.stack.undo.unshift();\n      }\n    } catch (_error) {\n      ignored = _error;\n      return this.clear();\n    }\n  };\n  UndoManager.prototype.redo = function () {\n    return this._change('redo', 'undo');\n  };\n  UndoManager.prototype.undo = function () {\n    return this._change('undo', 'redo');\n  };\n  UndoManager.prototype._getLastChangeIndex = function (delta) {\n    var index, lastIndex;\n    lastIndex = 0;\n    index = 0;\n    delta.ops.forEach(function (op) {\n      if (op.insert != null) {\n        return lastIndex = Math.max(index + (op.insert.length || 1), lastIndex);\n      } else if (op[\"delete\"] != null) {\n        return lastIndex = Math.max(index, lastIndex);\n      } else if (op.retain != null) {\n        if (op.attributes != null) {\n          lastIndex = Math.max(index + op.retain, lastIndex);\n        }\n        return index += op.retain;\n      }\n    });\n    return lastIndex;\n  };\n  UndoManager.prototype._change = function (source, dest) {\n    var change, index;\n    if (this.stack[source].length > 0) {\n      change = this.stack[source].pop();\n      this.lastRecorded = 0;\n      this.emittedDelta = change[source];\n      this.quill.updateContents(change[source], 'user');\n      this.emittedDelta = null;\n      index = this._getLastChangeIndex(change[source]);\n      this.quill.setSelection(index, index);\n      this.oldDelta = this.quill.getContents();\n      return this.stack[dest].push(change);\n    }\n  };\n  return UndoManager;\n}();\nQuill.registerModule('undo-manager', UndoManager);\nmodule.exports = UndoManager;","map":null,"metadata":{},"sourceType":"script"}