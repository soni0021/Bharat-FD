{"ast":null,"code":"var Delta,\n  Format,\n  Leaf,\n  Line,\n  LinkedList,\n  Normalizer,\n  dom,\n  _,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function (child, parent) {\n    for (var key in parent) {\n      if (__hasProp.call(parent, key)) child[key] = parent[key];\n    }\n    function ctor() {\n      this.constructor = child;\n    }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  };\n_ = require('lodash');\nDelta = require('rich-text').Delta;\ndom = require('../lib/dom');\nFormat = require('./format');\nLeaf = require('./leaf');\nLine = require('./line');\nLinkedList = require('../lib/linked-list');\nNormalizer = require('../lib/normalizer');\nLine = function (_super) {\n  __extends(Line, _super);\n  Line.CLASS_NAME = 'line';\n  Line.ID_PREFIX = 'line-';\n  function Line(doc, node) {\n    this.doc = doc;\n    this.node = node;\n    this.id = _.uniqueId(Line.ID_PREFIX);\n    this.formats = {};\n    dom(this.node).addClass(Line.CLASS_NAME);\n    this.rebuild();\n    Line.__super__.constructor.call(this, this.node);\n  }\n  Line.prototype.buildLeaves = function (node, formats) {\n    return _.each(dom(node).childNodes(), function (_this) {\n      return function (node) {\n        var nodeFormats;\n        node = Normalizer.normalizeNode(node);\n        nodeFormats = _.clone(formats);\n        _.each(_this.doc.formats, function (format, name) {\n          if (!format.isType(Format.types.LINE) && format.match(node)) {\n            return nodeFormats[name] = format.value(node);\n          }\n        });\n        if (Leaf.isLeafNode(node)) {\n          return _this.leaves.append(new Leaf(node, nodeFormats));\n        } else {\n          return _this.buildLeaves(node, nodeFormats);\n        }\n      };\n    }(this));\n  };\n  Line.prototype.deleteText = function (offset, length) {\n    var deleteLength, leaf, _ref;\n    if (!(length > 0)) {\n      return;\n    }\n    _ref = this.findLeafAt(offset), leaf = _ref[0], offset = _ref[1];\n    while (leaf != null && length > 0) {\n      deleteLength = Math.min(length, leaf.length - offset);\n      leaf.deleteText(offset, deleteLength);\n      length -= deleteLength;\n      leaf = leaf.next;\n      offset = 0;\n    }\n    return this.rebuild();\n  };\n  Line.prototype.findLeaf = function (leafNode) {\n    var curLeaf;\n    curLeaf = this.leaves.first;\n    while (curLeaf != null) {\n      if (curLeaf.node === leafNode) {\n        return curLeaf;\n      }\n      curLeaf = curLeaf.next;\n    }\n    return null;\n  };\n  Line.prototype.findLeafAt = function (offset, inclusive) {\n    var leaf;\n    if (inclusive == null) {\n      inclusive = false;\n    }\n    if (offset >= this.length - 1) {\n      return [this.leaves.last, this.leaves.last.length];\n    }\n    leaf = this.leaves.first;\n    while (leaf != null) {\n      if (offset < leaf.length || offset === leaf.length && inclusive) {\n        return [leaf, offset];\n      }\n      offset -= leaf.length;\n      leaf = leaf.next;\n    }\n    return [this.leaves.last, offset - this.leaves.last.length];\n  };\n  Line.prototype.format = function (name, value) {\n    var formats;\n    if (_.isObject(name)) {\n      formats = name;\n    } else {\n      formats = {};\n      formats[name] = value;\n    }\n    _.each(formats, function (_this) {\n      return function (value, name) {\n        var excludeFormat, format;\n        format = _this.doc.formats[name];\n        if (format.isType(Format.types.LINE)) {\n          if (format.config.exclude && _this.formats[format.config.exclude]) {\n            excludeFormat = _this.doc.formats[format.config.exclude];\n            if (excludeFormat != null) {\n              _this.node = excludeFormat.remove(_this.node);\n              delete _this.formats[format.config.exclude];\n            }\n          }\n          _this.node = format.add(_this.node, value);\n        }\n        if (value) {\n          return _this.formats[name] = value;\n        } else {\n          return delete _this.formats[name];\n        }\n      };\n    }(this));\n    return this.resetContent();\n  };\n  Line.prototype.formatText = function (offset, length, name, value) {\n    var format, leaf, leafOffset, leftNode, nextLeaf, rightNode, targetNode, _ref, _ref1, _ref2;\n    _ref = this.findLeafAt(offset), leaf = _ref[0], leafOffset = _ref[1];\n    format = this.doc.formats[name];\n    if (!(format != null && format.config.type !== Format.types.LINE)) {\n      return;\n    }\n    while (leaf != null && length > 0) {\n      nextLeaf = leaf.next;\n      if (value && leaf.formats[name] !== value || !value && leaf.formats[name] != null) {\n        targetNode = leaf.node;\n        if (leaf.formats[name] != null) {\n          dom(targetNode).splitAncestors(this.node);\n          while (!format.match(targetNode)) {\n            targetNode = targetNode.parentNode;\n          }\n        }\n        if (leafOffset > 0) {\n          _ref1 = dom(targetNode).split(leafOffset), leftNode = _ref1[0], targetNode = _ref1[1];\n        }\n        if (leaf.length > leafOffset + length) {\n          _ref2 = dom(targetNode).split(length), targetNode = _ref2[0], rightNode = _ref2[1];\n        }\n        format.add(targetNode, value);\n      }\n      length -= leaf.length - leafOffset;\n      leafOffset = 0;\n      leaf = nextLeaf;\n    }\n    return this.rebuild();\n  };\n  Line.prototype.insertText = function (offset, text, formats) {\n    var leaf, leafOffset, nextNode, node, prevNode, _ref, _ref1;\n    if (formats == null) {\n      formats = {};\n    }\n    if (!(text.length > 0)) {\n      return;\n    }\n    _ref = this.findLeafAt(offset), leaf = _ref[0], leafOffset = _ref[1];\n    if (_.isEqual(leaf.formats, formats)) {\n      leaf.insertText(leafOffset, text);\n      return this.resetContent();\n    } else {\n      node = _.reduce(formats, function (_this) {\n        return function (node, value, name) {\n          return _this.doc.formats[name].add(node, value);\n        };\n      }(this), this.node.ownerDocument.createTextNode(text));\n      _ref1 = dom(leaf.node).split(leafOffset), prevNode = _ref1[0], nextNode = _ref1[1];\n      if (nextNode) {\n        nextNode = dom(nextNode).splitAncestors(this.node).get();\n      }\n      this.node.insertBefore(node, nextNode);\n      return this.rebuild();\n    }\n  };\n  Line.prototype.optimize = function () {\n    Normalizer.optimizeLine(this.node);\n    return this.rebuild();\n  };\n  Line.prototype.rebuild = function (force) {\n    if (force == null) {\n      force = false;\n    }\n    if (!force && this.outerHTML != null && this.outerHTML === this.node.outerHTML) {\n      if (_.all(this.leaves.toArray(), function (_this) {\n        return function (leaf) {\n          return dom(leaf.node).isAncestor(_this.node);\n        };\n      }(this))) {\n        return false;\n      }\n    }\n    this.node = Normalizer.normalizeNode(this.node);\n    if (dom(this.node).length() === 0 && !this.node.querySelector(dom.DEFAULT_BREAK_TAG)) {\n      this.node.appendChild(this.node.ownerDocument.createElement(dom.DEFAULT_BREAK_TAG));\n    }\n    this.leaves = new LinkedList();\n    this.formats = _.reduce(this.doc.formats, function (_this) {\n      return function (formats, format, name) {\n        if (format.isType(Format.types.LINE)) {\n          if (format.match(_this.node)) {\n            formats[name] = format.value(_this.node);\n          } else {\n            delete formats[name];\n          }\n        }\n        return formats;\n      };\n    }(this), this.formats);\n    this.buildLeaves(this.node, {});\n    this.resetContent();\n    return true;\n  };\n  Line.prototype.resetContent = function () {\n    if (this.node.id !== this.id) {\n      this.node.id = this.id;\n    }\n    this.outerHTML = this.node.outerHTML;\n    this.length = 1;\n    this.delta = new Delta();\n    this.leaves.toArray().forEach(function (_this) {\n      return function (leaf) {\n        _this.length += leaf.length;\n        if (dom.EMBED_TAGS[leaf.node.tagName] != null) {\n          return _this.delta.insert(1, leaf.formats);\n        } else {\n          return _this.delta.insert(leaf.text, leaf.formats);\n        }\n      };\n    }(this));\n    return this.delta.insert('\\n', this.formats);\n  };\n  return Line;\n}(LinkedList.Node);\nmodule.exports = Line;","map":null,"metadata":{},"sourceType":"script"}